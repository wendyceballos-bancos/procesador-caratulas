
import streamlit as st
import pandas as pd
import numpy as np
import base64
import io
import os
from datetime import datetime, date
import warnings
import re

warnings.filterwarnings('ignore')

# Configuraci√≥n de la p√°gina
st.set_page_config(
    page_title="Vaciado de Car√°tulas Bancarias - Despegar",
    page_icon="üè¶",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Logo de Despegar embebido en base64
LOGO_DESPEGAR_BASE64 = """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"""

def mostrar_header_con_logo():
    """Muestra el header con logo de Despegar y t√≠tulo"""
    st.markdown(f"""
    <div style="display: flex; align-items: center; margin-bottom: 2rem; padding: 1rem; background: linear-gradient(90deg, #f8fafc 0%, #e2e8f0 100%); border-radius: 10px; border-left: 5px solid #1e3a8a;">
        <img src="data:image/png;base64,{LOGO_DESPEGAR_BASE64}" 
             style="height: 80px; margin-right: 25px;">
        <div>
            <h1 style="color: #1e3a8a; margin: 0; font-size: 2.5rem; font-weight: 700;">
                Vaciado de Car√°tulas Bancarias
            </h1>
            <p style="color: #475569; margin: 5px 0 0 0; font-size: 1.1rem; font-weight: 400;">
                Automatizaci√≥n de procesamiento financiero - Powered by Despegar
            </p>
        </div>
    </div>
    """, unsafe_allow_html=True)

# Archivo de mapeo Flex ‚Üí Moneda embebido (actualizado)
ARCHIVO_MAPEO_MONEDAS_BASE64 = """UEsDBBQABgAIAAAAIQCREKFLmQEAAPgGAAATAAgCW0NvbnRlbnRfVHlwZXNdLnhtbCCiBAIooAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"""

@st.cache_data
def cargar_mapeo_monedas():
    """Carga el mapeo de monedas desde el archivo Excel embebido actualizado"""
    try:
        # Decodificar el archivo base64
        archivo_bytes = base64.b64decode(ARCHIVO_MAPEO_MONEDAS_BASE64)
        
        # Leer el Excel desde memoria
        df_mapeo = pd.read_excel(io.BytesIO(archivo_bytes), engine='openpyxl')
        
        # Crear diccionario de mapeo
        mapeo_dict = dict(zip(df_mapeo['Flex Efectivo'].astype(str), df_mapeo['Moneda'].astype(str)))
        
        # Log para debug
        print(f"‚úÖ Mapeo de monedas cargado: {len(mapeo_dict)} entradas")
        print(f"‚úÖ Monedas disponibles: {sorted(df_mapeo['Moneda'].unique())}")
        
        return mapeo_dict, df_mapeo
        
    except Exception as e:
        st.warning(f"Error cargando mapeo actualizado: {e}")
        # Mapeo de respaldo b√°sico
        mapeo_respaldo = {
            'USD': 'USD', 'EUR': 'EUR', 'PEN': 'PEN', 'CLP': 'CLP', 
            'BRL': 'BRL', 'MXN': 'MXN', 'ARS': 'ARS', 'COP': 'COP', 'UYU': 'UYU'
        }
        return mapeo_respaldo, None

def limpiar_nombre_banco(nombre_hoja):
    """Extrae el nombre del banco desde el nombre de la hoja"""
    nombre_limpio = re.sub(r'\d+$', '', nombre_hoja)
    nombre_limpio = re.sub(r'\b(datos|data|info|informaci√≥n)\b', '', nombre_limpio, flags=re.IGNORECASE)
    nombre_limpio = nombre_limpio.strip().strip('_-. ')
    return nombre_limpio if nombre_limpio else nombre_hoja

def obtener_moneda_de_flex(flex_banco, mapeo_monedas):
    """
    Obtiene la moneda basada en el flex banco usando mapeo actualizado
    Implementa b√∫squeda exacta y por prefijos
    """
    if pd.isna(flex_banco) or flex_banco == '':
        return ''
    
    flex_str = str(flex_banco).strip()
    
    # 1. B√∫squeda exacta
    if flex_str in mapeo_monedas:
        return mapeo_monedas[flex_str]
    
    # 2. B√∫squeda por coincidencia parcial (contiene)
    for flex_clave, moneda in mapeo_monedas.items():
        if flex_str in flex_clave or flex_clave in flex_str:
            return moneda
    
    # 3. B√∫squeda por prefijos (para claves jer√°rquicas como 113.11121.1303...)
    partes_flex = flex_str.split('.')
    for i in range(len(partes_flex), 0, -1):
        prefijo = '.'.join(partes_flex[:i])
        for flex_clave, moneda in mapeo_monedas.items():
            if flex_clave.startswith(prefijo):
                return moneda
    
    # 4. B√∫squeda por c√≥digo de moneda contenido (fallback)
    flex_upper = flex_str.upper()
    codigos_moneda = ['USD', 'EUR', 'PEN', 'CLP', 'BRL', 'MXN', 'ARS', 'COP', 'UYU']
    for codigo in codigos_moneda:
        if codigo in flex_upper:
            return codigo
    
    return ''

def normalizar_fecha_sin_hora(fecha_value):
    """
    Normaliza diferentes tipos de fecha para eliminar la hora y dejar solo la fecha
    CORREGIDO: Siempre devuelve string para evitar problemas con Streamlit
    """
    try:
        if pd.isna(fecha_value) or fecha_value is None:
            return ''
        
        # Convertir todo a string al final para evitar problemas con Streamlit
        if hasattr(fecha_value, 'date') and callable(fecha_value.date):
            return fecha_value.date().strftime('%Y-%m-%d')
        
        if hasattr(fecha_value, 'strftime'):
            return fecha_value.strftime('%Y-%m-%d')
        
        fecha_str = str(fecha_value).strip()
        
        if ' ' in fecha_str and fecha_str != 'nan':
            try:
                fecha_parseada = pd.to_datetime(fecha_str, errors='coerce')
                if not pd.isna(fecha_parseada):
                    return fecha_parseada.strftime('%Y-%m-%d')
            except:
                pass
        
        if fecha_str and fecha_str != 'nan':
            try:
                fecha_parseada = pd.to_datetime(fecha_str, errors='coerce')
                if not pd.isna(fecha_parseada):
                    return fecha_parseada.strftime('%Y-%m-%d')
            except:
                pass
        
        return fecha_str if fecha_str != 'nan' else ''
    
    except Exception:
        return ''

def procesar_archivo_excel(archivo, progress_callback=None, log_callback=None):
    """Procesa el archivo Excel y devuelve los datos consolidados"""
    
    def log(mensaje):
        if log_callback:
            log_callback(mensaje)
        print(mensaje)
    
    def actualizar_progreso(valor):
        if progress_callback:
            progress_callback(valor)
    
    try:
        log("üîç Iniciando procesamiento del archivo...")
        
        # Cargar el mapeo de monedas actualizado
        mapeo_monedas, df_mapeo_original = cargar_mapeo_monedas()
        log(f"‚úÖ Mapeo de monedas actualizado cargado: {len(mapeo_monedas)} entradas")
        if df_mapeo_original is not None:
            monedas_disponibles = sorted(df_mapeo_original['Moneda'].unique())
            log(f"üí∞ Monedas disponibles: {monedas_disponibles}")
        
        # Leer todas las hojas del archivo
        try:
            todas_las_hojas = pd.read_excel(archivo, sheet_name=None, header=None, engine='openpyxl')
            log(f"üìÑ Archivo cargado: {len(todas_las_hojas)} hojas encontradas")
        except Exception as e:
            log(f"‚ùå Error al leer el archivo: {e}")
            return None, None, None, None
        
        # Filtrar hojas que no son de datos
        hojas_excluidas = ['resumen', 'summary', '√≠ndice', 'index', 'instrucciones', 'instructions', 'totales', 'total', 'config', 'configuraci√≥n']
        hojas_datos = []
        
        for nombre_hoja in todas_las_hojas.keys():
            if not any(excl.lower() in nombre_hoja.lower() for excl in hojas_excluidas):
                hojas_datos.append(nombre_hoja)
        
        log(f"üìä Hojas de datos detectadas: {hojas_datos}")
        actualizar_progreso(10)
        
        # Procesar cada hoja
        datos_consolidados = []
        resumen_proceso = []
        total_hojas = len(hojas_datos)
        
        for i, nombre_hoja in enumerate(hojas_datos):
            try:
                log(f"\nüîÑ Procesando hoja '{nombre_hoja}'...")
                
                df_hoja = todas_las_hojas[nombre_hoja]
                
                if len(df_hoja) < 13:
                    log(f"‚ö†Ô∏è  Hoja '{nombre_hoja}' tiene pocas filas ({len(df_hoja)}), omitiendo...")
                    resumen_proceso.append({
                        'Banco': limpiar_nombre_banco(nombre_hoja),
                        'Hoja': nombre_hoja,
                        'Registros': 0,
                        'Estado': 'Omitida - Pocas filas'
                    })
                    continue
                
                # Extraer encabezados desde la fila 11 (√≠ndice 10)
                encabezados = df_hoja.iloc[10].fillna('').astype(str)
                
                for j, enc in enumerate(encabezados):
                    if enc == '' or enc == 'nan':
                        encabezados.iloc[j] = f'Col_{j}'
                
                # Mapear columnas por nombre
                mapeo_columnas = {}
                for idx, nombre in enumerate(encabezados):
                    nombre_lower = str(nombre).lower().strip()
                    
                    if 'estado' in nombre_lower:
                        mapeo_columnas['Estado'] = idx
                    elif 'aging' in nombre_lower:
                        mapeo_columnas['Aging'] = idx
                    elif 'fecha' in nombre_lower and 'contable' in nombre_lower:
                        mapeo_columnas['Fecha'] = idx
                    elif 'fecha' in nombre_lower and 'transac' in nombre_lower:
                        mapeo_columnas['Fecha transacci√≥n'] = idx
                    elif 'categor√≠a' in nombre_lower or 'categoria' in nombre_lower:
                        mapeo_columnas['Categor√≠a'] = idx
                    elif 'monto' in nombre_lower and ('funcional' in nombre_lower or 'total' in nombre_lower):
                        mapeo_columnas['Monto'] = idx
                    elif 'concepto' in nombre_lower:
                        mapeo_columnas['Concepto'] = idx
                    elif 'responsable' in nombre_lower:
                        mapeo_columnas['Responsable'] = idx
                    elif 'flex' in nombre_lower and 'contable' in nombre_lower:
                        mapeo_columnas['Flex contable'] = idx
                    elif 'flex' in nombre_lower and ('banco' in nombre_lower or 'efectivo' in nombre_lower):
                        mapeo_columnas['Flex banco'] = idx
                    elif 'tipo' in nombre_lower and 'extracto' in nombre_lower:
                        mapeo_columnas['Tipo extracto'] = idx
                
                # Mapeos fijos por √≠ndice
                if len(encabezados) > 7:
                    mapeo_columnas['Numero de transacci√≥n'] = 7
                if len(encabezados) > 11:
                    mapeo_columnas['Proveedor/Cliente'] = 11
                
                log(f"üìã Columnas mapeadas: {list(mapeo_columnas.keys())}")
                
                # Procesar filas desde el √≠ndice 12
                filas_validas = []
                
                for fila_idx in range(12, len(df_hoja)):
                    fila = df_hoja.iloc[fila_idx]
                    criterios_cumplidos = 0
                    
                    # Criterio 1: Aging num√©rico > 0
                    if 'Aging' in mapeo_columnas:
                        try:
                            aging_val = pd.to_numeric(fila.iloc[mapeo_columnas['Aging']], errors='coerce')
                            if not pd.isna(aging_val) and aging_val > 0:
                                criterios_cumplidos += 1
                        except:
                            pass
                    
                    # Criterio 2: Fecha no vac√≠a
                    fecha_encontrada = False
                    for col_fecha in ['Fecha', 'Fecha transacci√≥n']:
                        if col_fecha in mapeo_columnas:
                            fecha_val = str(fila.iloc[mapeo_columnas[col_fecha]])
                            if fecha_val and fecha_val != 'nan' and fecha_val.strip():
                                fecha_encontrada = True
                                break
                    if fecha_encontrada:
                        criterios_cumplidos += 1
                    
                    # Criterio 3: Monto num√©rico distinto de 0
                    if 'Monto' in mapeo_columnas:
                        try:
                            monto_val = pd.to_numeric(fila.iloc[mapeo_columnas['Monto']], errors='coerce')
                            if not pd.isna(monto_val) and monto_val != 0:
                                criterios_cumplidos += 1
                        except:
                            pass
                    
                    # Criterio 4: Responsable con longitud > 2
                    if 'Responsable' in mapeo_columnas:
                        responsable_val = str(fila.iloc[mapeo_columnas['Responsable']])
                        if responsable_val and responsable_val != 'nan' and len(responsable_val.strip()) > 2:
                            criterios_cumplidos += 1
                    
                    # Criterio 5: Flex contable que contenga '105.' y longitud > 10
                    if 'Flex contable' in mapeo_columnas:
                        flex_cont_val = str(fila.iloc[mapeo_columnas['Flex contable']])
                        if flex_cont_val and flex_cont_val != 'nan' and '105.' in flex_cont_val and len(flex_cont_val.strip()) > 10:
                            criterios_cumplidos += 1
                    
                    if criterios_cumplidos >= 3:
                        filas_validas.append(fila_idx)
                
                if not filas_validas:
                    log(f"‚ö†Ô∏è  No se encontraron filas v√°lidas en '{nombre_hoja}'")
                    resumen_proceso.append({
                        'Banco': limpiar_nombre_banco(nombre_hoja),
                        'Hoja': nombre_hoja,
                        'Registros': 0,
                        'Estado': 'Sin datos v√°lidos'
                    })
                    continue
                
                # Crear DataFrame con las filas v√°lidas
                df_procesado = pd.DataFrame()
                
                columnas_objetivo = [
                    'Estado', 'Aging', 'Fecha', 'Fecha transacci√≥n', 'Categor√≠a', 
                    'Numero de transacci√≥n', 'Proveedor/Cliente', 'Monto', 'Concepto', 
                    'Responsable', 'Flex contable', 'Flex banco', 'Tipo extracto',
                    'Moneda', 'BANCO'
                ]
                
                for col in columnas_objetivo[:-2]:
                    if col in mapeo_columnas:
                        valores = [df_hoja.iloc[idx, mapeo_columnas[col]] if idx < len(df_hoja) and mapeo_columnas[col] < len(df_hoja.columns) else '' for idx in filas_validas]
                        df_procesado[col] = valores
                    else:
                        df_procesado[col] = [''] * len(filas_validas)
                
                # Agregar columna de moneda usando mapeo actualizado
                monedas_asignadas = 0
                if 'Flex banco' in mapeo_columnas:
                    monedas_aplicadas = []
                    for flex_val in df_procesado['Flex banco']:
                        moneda = obtener_moneda_de_flex(flex_val, mapeo_monedas)
                        monedas_aplicadas.append(moneda)
                        if moneda:
                            monedas_asignadas += 1
                    
                    df_procesado['Moneda'] = monedas_aplicadas
                    log(f"üí∞ Monedas asignadas: {monedas_asignadas} de {len(filas_validas)} registros")
                else:
                    df_procesado['Moneda'] = ''
                
                # Agregar columna de banco
                df_procesado['BANCO'] = limpiar_nombre_banco(nombre_hoja)
                
                # Limpiar datos
                for col in df_procesado.columns:
                    if df_procesado[col].dtype == 'object':
                        df_procesado[col] = df_procesado[col].astype(str).str.strip()
                        df_procesado[col] = df_procesado[col].replace('nan', '')
                
                datos_consolidados.append(df_procesado)
                
                log(f"‚úÖ Hoja '{nombre_hoja}' procesada: {len(filas_validas)} registros v√°lidos")
                resumen_proceso.append({
                    'Banco': limpiar_nombre_banco(nombre_hoja),
                    'Hoja': nombre_hoja,
                    'Registros': len(filas_validas),
                    'Estado': 'Procesada correctamente'
                })
                
                progreso = 10 + (60 * (i + 1) / total_hojas)
                actualizar_progreso(int(progreso))
                
            except Exception as e:
                log(f"‚ùå Error procesando hoja '{nombre_hoja}': {e}")
                resumen_proceso.append({
                    'Banco': limpiar_nombre_banco(nombre_hoja),
                    'Hoja': nombre_hoja,
                    'Registros': 0,
                    'Estado': f'Error: {str(e)[:50]}'
                })
        
        if not datos_consolidados:
            log("‚ùå No se pudo procesar ninguna hoja")
            return None, None, None, None
        
        # Consolidar todos los datos
        log("\nüîó Consolidando datos...")
        df_final = pd.concat(datos_consolidados, ignore_index=True)
        actualizar_progreso(75)
        
        # Limpiar datos finales
        for col in df_final.columns:
            if df_final[col].dtype == 'object':
                df_final[col] = df_final[col].astype(str).str.strip()
                df_final[col] = df_final[col].replace('nan', '')
                if col not in ['Proveedor/Cliente', 'Moneda']:
                    df_final[col] = df_final[col].replace('', np.nan)
        
        # NORMALIZAR FECHAS SIN HORA - CORREGIDO PARA EVITAR TIMESTAMP ERRORS
        log("üìÖ Normalizando fechas sin hora...")
        if 'Fecha' in df_final.columns:
            fechas_procesadas = 0
            fechas_normalizadas = []
            
            for idx in df_final.index:
                fecha_original = df_final.at[idx, 'Fecha']
                fecha_normalizada = normalizar_fecha_sin_hora(fecha_original)
                fechas_normalizadas.append(fecha_normalizada)
                if fecha_normalizada:
                    fechas_procesadas += 1
            
            # Asignar todas las fechas de una vez como strings
            df_final['Fecha'] = fechas_normalizadas
            log(f"‚úÖ Fechas normalizadas: {fechas_procesadas} registros procesados")
        
        actualizar_progreso(85)
        
        # Calcular DEBE/HABER/SALDO
        log("üí∞ Calculando DEBE, HABER y SALDO...")
        
        col_estado = None
        col_monto = None
        col_tipo_extracto = None
        
        for col in df_final.columns:
            if 'estado' in col.lower():
                col_estado = col
            if 'monto' in col.lower():
                col_monto = col
            if 'tipo' in col.lower() and 'extracto' in col.lower():
                col_tipo_extracto = col
        
        log(f"üîç Columnas identificadas - Estado: {col_estado}, Monto: {col_monto}, Tipo extracto: {col_tipo_extracto}")
        
        if col_estado and col_monto:
            df_final['DEBE'] = 0.0
            df_final['HABER'] = 0.0
            
            textos_debe = [
                "III. Partidas contabilizadas pendientes de debitar en el extracto bancario",
                "V. Partidas acreditadas en el extracto bancario, pendientes de contabilizar"
            ]
            
            textos_haber = [
                "II. Partidas contabilizadas pendientes de acreditar en el extracto bancario",
                "IV. Partidas debitadas en el extracto bancario, pendientes de contabilizar"
            ]
            
            debe_count = 0
            haber_count = 0
            
            for idx, row in df_final.iterrows():
                estado_text = str(row[col_estado]).strip()
                tipo_extracto = str(row.get(col_tipo_extracto, '')).strip().upper() if col_tipo_extracto else ''
                
                try:
                    monto_val = pd.to_numeric(row[col_monto], errors='coerce')
                    if pd.isna(monto_val):
                        monto_val = 0
                except:
                    monto_val = 0
                
                if tipo_extracto == 'DEBIT':
                    df_final.at[idx, 'DEBE'] = abs(monto_val)
                    df_final.at[idx, 'HABER'] = 0.0
                    debe_count += 1
                elif tipo_extracto == 'CREDIT':
                    df_final.at[idx, 'HABER'] = abs(monto_val)
                    df_final.at[idx, 'DEBE'] = 0.0
                    haber_count += 1
                elif any(texto in estado_text for texto in textos_debe):
                    df_final.at[idx, 'DEBE'] = abs(monto_val)
                    df_final.at[idx, 'HABER'] = 0.0
                    debe_count += 1
                elif any(texto in estado_text for texto in textos_haber):
                    df_final.at[idx, 'HABER'] = abs(monto_val)
                    df_final.at[idx, 'DEBE'] = 0.0
                    haber_count += 1
                else:
                    if monto_val > 0:
                        df_final.at[idx, 'DEBE'] = monto_val
                        df_final.at[idx, 'HABER'] = 0.0
                        debe_count += 1
                    elif monto_val < 0:
                        df_final.at[idx, 'HABER'] = abs(monto_val)
                        df_final.at[idx, 'DEBE'] = 0.0
                        haber_count += 1
            
            df_final['SALDO'] = df_final['DEBE'] - df_final['HABER']
            log(f"üí∞ C√°lculo completado: {debe_count} registros en DEBE, {haber_count} en HABER")
            
        else:
            log("‚ö†Ô∏è  No se pudieron identificar columnas de Estado o Monto para calcular DEBE/HABER")
            df_final['DEBE'] = 0.0
            df_final['HABER'] = 0.0
            df_final['SALDO'] = 0.0
        
        # Reordenar columnas
        columnas_finales = [
            'Estado', 'Aging', 'Fecha', 'Fecha transacci√≥n', 'Categor√≠a', 
            'Numero de transacci√≥n', 'Proveedor/Cliente', 'Monto', 'Concepto', 
            'Responsable', 'Flex contable', 'Flex banco', 'Tipo extracto',
            'Moneda', 'BANCO', 'DEBE', 'HABER', 'SALDO'
        ]
        
        for col in df_final.columns:
            if col not in columnas_finales:
                columnas_finales.append(col)
        
        df_final = df_final[[col for col in columnas_finales if col in df_final.columns]]
        
        # Crear DataFrames de resumen
        df_resumen = pd.DataFrame(resumen_proceso)
        
        # Estad√≠sticas de monedas
        if 'Moneda' in df_final.columns:
            monedas_stats = df_final['Moneda'].value_counts()
            df_monedas = pd.DataFrame({
                'Moneda': monedas_stats.index,
                'Registros': monedas_stats.values
            }).reset_index(drop=True)
        else:
            df_monedas = pd.DataFrame()
        
        df_estadisticas = pd.DataFrame({
            'M√©trica': [
                'Total de registros procesados',
                'N√∫mero de bancos procesados', 
                'Total DEBE',
                'Total HABER',
                'SALDO FINAL',
                'Monedas diferentes encontradas',
                'Fecha de procesamiento',
                'Archivo procesado'
            ],
            'Valor': [
                len(df_final),
                len(df_final['BANCO'].unique()) if 'BANCO' in df_final.columns else 0,
                f"{df_final['DEBE'].sum():,.2f}" if 'DEBE' in df_final.columns else 0,
                f"{df_final['HABER'].sum():,.2f}" if 'HABER' in df_final.columns else 0,
                f"{df_final['SALDO'].sum():,.2f}" if 'SALDO' in df_final.columns else 0,
                df_final['Moneda'].nunique() if 'Moneda' in df_final.columns else 0,
                datetime.now().strftime('%d/%m/%Y %H:%M:%S'),
                'Archivo subido'
            ]
        })
        
        actualizar_progreso(100)
        log(f"\nüéâ ¬°Procesamiento completado exitosamente!")
        log(f"üìä Total de registros: {len(df_final)}")
        log(f"üè¶ Bancos procesados: {len(df_final['BANCO'].unique()) if 'BANCO' in df_final.columns else 0}")
        log(f"üí∞ Total DEBE: {df_final['DEBE'].sum():,.2f}")
        log(f"üí∞ Total HABER: {df_final['HABER'].sum():,.2f}")
        log(f"üí∞ SALDO: {df_final['SALDO'].sum():,.2f}")
        log(f"üí± Monedas procesadas: {df_final['Moneda'].nunique() if 'Moneda' in df_final.columns else 0}")
        
        return df_final, df_resumen, df_estadisticas, df_monedas
        
    except Exception as e:
        log(f"‚ùå Error cr√≠tico durante el procesamiento: {e}")
        return None, None, None, None

def main():
    """Funci√≥n principal de la aplicaci√≥n Streamlit"""
    
    # Header con logo de Despegar
    mostrar_header_con_logo()
    st.markdown("---")
    st.markdown("""
    ### üìã Instrucciones de uso:
    1. **Sube tu archivo Excel** con las car√°tulas bancarias
    2. **Haz clic en 'Procesar archivo'** para iniciar el an√°lisis
    3. **Descarga los resultados** en formato Excel
    
    ‚ö†Ô∏è  **Importante**: El archivo debe tener encabezados en la fila 11 y datos a partir de la fila 13.

    """)
    
    # Sidebar con informaci√≥n del mapeo
    st.sidebar.header("‚öôÔ∏è Configuraci√≥n")
    st.sidebar.info("""
    **Formato esperado:**
    - Encabezados en fila 11
    - Datos desde fila 13
    - Columnas: Estado, Aging, Fecha, Monto, etc.
    """)
    
    # Mostrar informaci√≥n del mapeo de monedas
    with st.sidebar.expander("üí± Mapeo de Monedas"):
        try:
            mapeo_monedas, df_mapeo = cargar_mapeo_monedas()
            if df_mapeo is not None:
                st.write(f"**Total de entradas:** {len(mapeo_monedas)}")
                st.write(f"**Monedas disponibles:** {len(df_mapeo['Moneda'].unique())}")
                monedas_lista = sorted(df_mapeo['Moneda'].unique())
                st.write("**C√≥digos:**")
                for moneda in monedas_lista:
                    st.write(f"‚Ä¢ {moneda}")
            else:
                st.write("Mapeo b√°sico de respaldo cargado")
        except Exception as e:
            st.write(f"Error: {e}")
    
    # Upload de archivo
    archivo_subido = st.file_uploader(
        "üìÅ Selecciona el archivo Excel con las car√°tulas",
        type=['xlsx', 'xlsm', 'xls'],
        help="Formatos soportados: .xlsx, .xlsm, .xls"
    )
    
    if archivo_subido is not None:
        st.success(f"‚úÖ Archivo cargado: {archivo_subido.name}")
        
        # Mostrar informaci√≥n del archivo
        col1, col2, col3 = st.columns(3)
        with col1:
            st.metric("üìÑ Nombre", archivo_subido.name)
        with col2:
            st.metric("üì¶ Tama√±o", f"{archivo_subido.size / 1024:.1f} KB")
        with col3:
            st.metric("üìã Tipo", archivo_subido.type)
        
        # Bot√≥n para procesar
        if st.button("üöÄ Procesar archivo", type="primary"):
            
            # Contenedores para progreso y logs
            progress_container = st.container()
            log_container = st.container()
            
            with progress_container:
                st.subheader("üìä Progreso del procesamiento")
                progress_bar = st.progress(0)
                status_text = st.empty()
            
            with log_container:
                st.subheader("üìù Registro de actividad")
                log_area = st.empty()
            
            # Variables para logs
            logs = []
            
            def actualizar_progreso(valor):
                progress_bar.progress(valor)
                status_text.text(f"Progreso: {valor}%")
            
            def agregar_log(mensaje):
                logs.append(mensaje)
                log_area.text_area(
                    "Logs:", 
                    value="\n".join(logs), 
                    height=200,
                    key=f"logs_{len(logs)}"
                )
            
            # Procesar archivo
            try:
                df_final, df_resumen, df_estadisticas, df_monedas = procesar_archivo_excel(
                    archivo_subido,
                    progress_callback=actualizar_progreso,
                    log_callback=agregar_log
                )
                
                if df_final is not None:
                    st.success("üéâ ¬°Archivo procesado exitosamente!")
                    
                    # Mostrar estad√≠sticas
                    st.subheader("üìà Estad√≠sticas del procesamiento")
                    col1, col2, col3, col4 = st.columns(4)
                    
                    with col1:
                        st.metric("üìä Registros", len(df_final))
                    with col2:
                        bancos_unicos = len(df_final['BANCO'].unique()) if 'BANCO' in df_final.columns else 0
                        st.metric("üè¶ Bancos", bancos_unicos)
                    with col3:
                        suma_debe = df_final['DEBE'].sum() if 'DEBE' in df_final.columns else 0
                        st.metric("üí∞ Total DEBE", f"{suma_debe:,.2f}")
                    with col4:
                        suma_haber = df_final['HABER'].sum() if 'HABER' in df_final.columns else 0
                        st.metric("üí∞ Total HABER", f"{suma_haber:,.2f}")
                    
                    # Mostrar SALDO final y monedas
                    col1, col2 = st.columns(2)
                    with col1:
                        saldo_final = suma_debe - suma_haber
                        if saldo_final > 0:
                            st.success(f"üí∞ **SALDO FINAL: ${saldo_final:,.2f}** (A favor)")
                        elif saldo_final < 0:
                            st.error(f"üí∞ **SALDO FINAL: ${abs(saldo_final):,.2f}** (En contra)")
                        else:
                            st.info(f"üí∞ **SALDO FINAL: $0.00** (Balanceado)")
                    
                    with col2:
                        if 'Moneda' in df_final.columns:
                            monedas_procesadas = df_final['Moneda'].nunique()
                            st.info(f"üí± **{monedas_procesadas} monedas diferentes** procesadas")
                    
                    # Tabs para mostrar resultados
                    tab1, tab2, tab3, tab4, tab5 = st.tabs([
                        "üìã Datos Consolidados", 
                        "üí± An√°lisis de Monedas", 
                        "üìÖ Vista de Fechas", 
                        "üìä Resumen del Proceso", 
                        "üìà Estad√≠sticas"
                    ])
                    
                    with tab1:
                        st.subheader("üìã Datos Consolidados")
                        st.dataframe(df_final, use_container_width=True)
                        st.info(f"Total de registros: {len(df_final)}")
                        
                        # Mostrar muestra por DEBE/HABER
                        col1, col2 = st.columns(2)
                        
                        with col1:
                            debe_registros = df_final[df_final['DEBE'] > 0]
                            if len(debe_registros) > 0:
                                st.subheader(f"üí∞ DEBE ({len(debe_registros)} registros)")
                                st.dataframe(
                                    debe_registros[['Estado', 'Fecha', 'Moneda', 'DEBE', 'BANCO']].head(5), 
                                    use_container_width=True
                                )
                        
                        with col2:
                            haber_registros = df_final[df_final['HABER'] > 0]
                            if len(haber_registros) > 0:
                                st.subheader(f"üí∞ HABER ({len(haber_registros)} registros)")
                                st.dataframe(
                                    haber_registros[['Estado', 'Fecha', 'Moneda', 'HABER', 'BANCO']].head(5), 
                                    use_container_width=True
                                )
                    
                    with tab2:
                        st.subheader("üí± An√°lisis de Monedas")
                        
                        if df_monedas is not None and len(df_monedas) > 0:
                            st.dataframe(df_monedas, use_container_width=True)
                            
                            # Gr√°fico de monedas
                            st.subheader("üìä Distribuci√≥n por Moneda")
                            st.bar_chart(df_monedas.set_index('Moneda'))
                            
                            # Detalle por moneda
                            st.subheader("üí∞ Totales por Moneda")
                            if 'Moneda' in df_final.columns:
                                moneda_totales = df_final.groupby('Moneda').agg({
                                    'DEBE': 'sum',
                                    'HABER': 'sum',
                                    'SALDO': 'sum'
                                }).round(2)
                                st.dataframe(moneda_totales, use_container_width=True)
                        else:
                            st.warning("No se encontraron monedas asignadas")
                            
                            # Mostrar registros sin moneda
                            sin_moneda = df_final[df_final['Moneda'] == '']
                            if len(sin_moneda) > 0:
                                st.subheader("‚ö†Ô∏è Registros sin moneda asignada")
                                st.dataframe(sin_moneda[['Flex banco', 'BANCO', 'Monto']].head(10), use_container_width=True)
                    
                    with tab3:
                        st.subheader("üìÖ Vista de Fechas Normalizadas")
                        if 'Fecha' in df_final.columns:
                            fechas_df = df_final[['Fecha', 'BANCO', 'Moneda', 'Monto']].copy()
                            fechas_df = fechas_df[fechas_df['Fecha'].notna() & (fechas_df['Fecha'] != '')]
                            
                            if len(fechas_df) > 0:
                                st.dataframe(fechas_df.head(20), use_container_width=True)
                                
                                col1, col2, col3 = st.columns(3)
                                with col1:
                                    st.metric("üìÖ Total con fecha", len(fechas_df))
                                with col2:
                                    st.metric("üìÖ Fechas √∫nicas", fechas_df['Fecha'].nunique())
                                with col3:
                                    if len(fechas_df) > 0:
                                        st.metric("üìÖ Formato", fechas_df['Fecha'].iloc[0])
                            else:
                                st.warning("No se encontraron fechas v√°lidas")
                        else:
                            st.warning("No se encontr√≥ columna de Fecha")
                    
                    with tab4:
                        st.subheader("üìä Resumen del Proceso")
                        if df_resumen is not None:
                            st.dataframe(df_resumen, use_container_width=True)
                        else:
                            st.warning("No hay datos de resumen disponibles")
                    
                    with tab5:
                        st.subheader("üìà Estad√≠sticas Generales")
                        if df_estadisticas is not None:
                            st.dataframe(df_estadisticas, use_container_width=True)
                        else:
                            st.warning("No hay estad√≠sticas disponibles")
                    
                    # Generar archivo Excel para descarga
                    st.subheader("üíæ Descargar resultados")
                    
                    # Crear archivo Excel en memoria - SOLO DATOS CONSOLIDADOS
                    output = io.BytesIO()
                    
                    with pd.ExcelWriter(output, engine='openpyxl') as writer:
                        df_final.to_excel(writer, sheet_name='Datos_Consolidados', index=False)
                        # Solo se incluye la hoja principal seg√∫n solicitud del usuario
                    
                    # Preparar archivo para descarga
                    excel_data = output.getvalue()
                    fecha_actual = datetime.now().strftime('%Y%m%d_%H%M%S')
                    nombre_archivo = f'caratulas_vaciado_{fecha_actual}.xlsx'
                    
                    st.download_button(
                        label="üì• Descargar archivo Excel",
                        data=excel_data,
                        file_name=nombre_archivo,
                        mime='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
                        type="primary"
                    )
                    
                    st.success("‚úÖ ¬°Listo! Haz clic en el bot√≥n de arriba para descargar el archivo procesado.")
                    
                else:
                    st.error("‚ùå No se pudo procesar el archivo. Revisa los logs para m√°s informaci√≥n.")
                    
            except Exception as e:
                st.error(f"‚ùå Error durante el procesamiento: {e}")
                agregar_log(f"Error cr√≠tico: {e}")
    
    # Footer con branding de Despegar
    st.markdown("---")
    st.markdown("""
    <div style="text-align: center; color: #6b7280; padding: 1rem;">
        <p><strong>üîß Desarrollado para automatizar el procesamiento de car√°tulas bancarias</strong></p>
        <p>üí± <strong>Mapeo de monedas actualizado</strong>: 136 entradas de Flex ‚Üí Moneda</p>
        <p>üìÖ <strong>Fechas normalizadas</strong>: Sin hora (formato YYYY-MM-DD)</p>
        <p>‚ú® <strong>Powered by Despegar</strong> - Tecnolog√≠a corporativa avanzada</p>
    </div>
    """, unsafe_allow_html=True)

if __name__ == "__main__":
    main()
